In the name of God

-  `grep [<options>] <pattern> [<file>]*`
   -  Pattern type
      -  `-F, --fixed-strings`
      -  ðŸ”¸ `-G, --basic-regexp` (BRE)
      -  `-E, --extended-regexp` (ERE)
      -  ðŸ’™ `-P, --perl-regexp` (PCRE)
   -  Matching control
      -  `-e, --regexp= <pattern>` can be used to give multiple patterns (or patterns starting with '-')
      -  `-f, --file= <file>` read patterns from file.
      -  ðŸ’™ `-i, --ignore-case`
      -  ðŸ’™ `-v, --invert-match`
      -  `-w, --word-regexp` match whole-words. (letters, digits and underscore are considered inside words)
      -  `-x, --line-regexp` match whole-lines. Match must start at the beginning of some line, and finish at the end of some line.
   -  Output
      -  `-c, --count`
      -  ðŸ’™ `-l, --files-with-matches` just file names
      -  ðŸ’™ `-L, --files-without-matches` just file names (of course!)
      -  `-m, --max-count= <num>`
      -  `-o, --only-matching` print only the matching part of the lines
      -  `-q, --quiet, --silent` just error code, no output (success if match found but errors)
      -  `-s, --no-messages` no error messages
   -  Output line prefix / Input line endings
      -  `-b, --byte-offset`
      -  `-h, --no-filename`
      -  ðŸ”¸ `-H, --with-filename`
      -  `--label= <label>` label input coming from sdtin
      -  ðŸ’™ `-n, --line-number`
      -  `-T, --initial-tab` indent the content lines
      -  `-u, --unix-byte-offsets` when used with `-b`, counts offsets excluding CRs out of new lines (only Windows)
      -  `-U, --binary` do not remove CRs from text files (only Windows)
      -  `-Z, --null` put NUL character after file names
         -  `-lZ` can be used with `find -print0`, `perl -0`, `sort -z` and `xargs -0`
      -  `-z, --null-data` read lines using NUL as line-terminating character
   -  Context lines control
      -  ðŸ’™ `-A, --after-context= <num>`
      -  ðŸ’™ `-B, --before-context= <num>`
      -  ðŸ’™ `-C, --context= <num>` or `-<num>`
   -  File selection
      -  `--binary-files=(binary|text|without-match)`
         -  ðŸ”¸ `binary` print a one-line message if the file matches, or nothing if does not match
         -  `text `process binary files as text
            -  equivalent: `-a, --text`
         -  `without-match` do not process binary files
            -  ðŸ’™ equivalent: `-I`
      -  `-D, --devices= (read|skip)` if file is a device, FIFO or socket
      -  `-d, --directories= (read|skip|recurse)`
         -  ðŸ”¸ `read` read directories as if they are files
         -  `recurse`
            -  ðŸ’™ equivalent: `-r, --recursive`
      -  `-R, --dereference-recursive` like `-r`, also follow symbolic links
      -  `--exclude= <pattern>`
         -  `<pattern>` can have `*`, `?` and `[...]` as wildcards and `\` as escape character.
      -  `--exclude-from= <file>` read exclude patterns from file
      -  `--exclude-dir= <file>` exclude from recursive search
      -  `--include= <pattern>` search **only** the matching files